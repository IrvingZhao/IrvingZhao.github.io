{"meta":{"title":"Hexo","subtitle":"","description":"","author":"IrvingZhao","url":"http://irving.ren","root":"/"},"pages":[],"posts":[{"title":"前端vue新老项目同步运行方案","slug":"前端vue新老项目同步运行方案","date":"2020-01-20T07:18:35.410Z","updated":"2020-01-20T08:05:53.108Z","comments":true,"path":"2020/01/20/前端vue新老项目同步运行方案/","link":"","permalink":"http://irving.ren/2020/01/20/%E5%89%8D%E7%AB%AFvue%E6%96%B0%E8%80%81%E9%A1%B9%E7%9B%AE%E5%90%8C%E6%AD%A5%E8%BF%90%E8%A1%8C%E6%96%B9%E6%A1%88/","excerpt":"","text":"关于Vue新老项目并行方案介绍使用场景 Vue新老系统并行产生场景：技术架构迭代时的，由于原有项目的架构无法适应业务的发展需要，从而做项目重构时，会出现新老系统并行的需求。 所需技术点 nginx 配置 vue-router配置 webpack打包配置 方案操作流程路径规划 需新老系统进行访问basepath规划，例如：http://host/n 访问新系统，http://host/o 访问老系统 系统改造 系统改造需调整项目中的路由配置，webpack打包配置，登录信息配置等其他相关内容 以下说明均以/n为新系统访问basepath，/o为老系统访问的basepath 路由配置调整 VueRouter 初始化参数，老系统：{base:&quot;/o/&quot;,mode:&quot;history&quot;}，新系统：{base:&quot;/n/&quot;,mode:&quot;history&quot;} VueRouter中添加全局前置守卫：router.beforeEach，守卫中需根据每次路由跳转时的地址，进行分发。分发时需定义规则，如：/n/*跳转至新系统，/o/*跳转至老系统，其他地址跳转当前系统。 一下代码为老系统中的跳转代码，新系统则与老系统相反 123456789101112131415const newPathReg = /^\\/n\\//;const oldPathReg = /^\\/o\\//;router.beforeEach((to, from, next) =&gt; &#123; if (oldPathReg.test(to.path)) &#123; const toPath = \"/\" + to.path.replace(oldPathReg, \"\"); next(toPath); &#125; else &#123; if (newPathReg.test(to.path)) &#123; window.location.href = to.path; &#125; else &#123; next(); &#125; &#125;&#125;); webpack配置 Webpack配置，webpack.config.js中的output.publicPath需与路由中的base值保持一致，用于打包时，不同的静态资源能够有相同的前缀。 对于vue-cli 2.0 的项目，需要调整config/index.js中的assetsPublicPath 对于vue-cli 3.0 的项目，需要设置vue.config.js中的publicPath nginx配置 在nginx中，需配置不同的路径指向不同的静态资源 12345678910111213141516171819server &#123; location &#x2F; &#123; try_files &amp;uri $uri&#x2F; &#x2F;o&#x2F;index.html?&amp;args; &#125; location &#x2F;o &#123; root &#x2F;static-root; index index.html index.htm; try_files $uri $uri&#x2F; &#x2F;o&#x2F;index.html?&amp;args; &#125; location &#x2F;n &#123; root &#x2F;static-root; index index.html index.htm; try_files $uri $uri&#x2F; &#x2F;n&#x2F;index.html?&amp;args; &#125; &#x2F;&#x2F; 其他转发配置&#125; 根据上面的nginx配置，老系统代码存放目录/static-root/n，新系统代码存放目录/static-root/o，默认跳转至老系统首页 应用此配置时，切记不可配置server的root项 注意事项 通过以上的配置，新老系统可以同时在同一域名下完成访问，并且新老系统中，可以根据地址转发规则，相互跳转 在调整配置时，需要注意新老系统中的一些全局配置信息，例如：登录配置、登陆信息保存、检查、登录页跳转、sessionStrage的使用","categories":[],"tags":[]},{"title":"前端基础项目总结","slug":"前端基础项目总结","date":"2020-01-09T10:13:01.485Z","updated":"2020-01-09T10:28:53.279Z","comments":true,"path":"2020/01/09/前端基础项目总结/","link":"","permalink":"http://irving.ren/2020/01/09/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"前端基础项目总结 前端项目开发过程中，在技术选型结束后，通常会选取组件库、约束项目结构、目录结构、模块结构 组件库 基于Element-ui v2.13.0组件库进行开发 工程模块结构整体项目下分如下项目： 基础框架工程 - 提供组件库扩展、复写、工具类等内容 template工程 - 用于构建业务模块项目的模板项目，提供基础启动、配置、目录约束、文件抛出约束等约束性内容 部署工程 - 用于集成测试、联调、线上打包部署使用，主依赖基础框架工程，将需要构建的业务模块工程加入依赖，并根据引入规范进行引入 业务模块工程 - 用于编写业务模块内容 该结构遇到的问题及解决方案 开发中遇到基础框架出现问题。 可优先将业务模块中的引用源码修改，并同步基础框架工程，后续根据需求，进行整体修改、调整、适配 业务模块工程进行多模块集成测试部署 在该场景下，多模块的应用频繁修改发布测试是比较重要的问题。 解决方案1：可使用link的方式，由部署工程link业务模块工程，在测试部署时，更新业务模块工程，而后编译部署工程，从而实现部署（已测试） 解决方案2：细化部署文件目录结构，编译业务模块后，直接将业务模块的内容按照目录约束，更新至部署目录。此方案需关闭chunk的hash模式，在浏览器强缓存的情况下会影响页面刷新。 解决方案3：由解决方案2进行扩展，编写plugin，实现部署工程对于业务模块中的chunk文件的定义及声明动态依赖，从而实现业务模块的独立部署","categories":[],"tags":[]},{"title":"Node - 手动Proxy","slug":"Node - 手动Proxy","date":"2020-01-08T09:35:48.739Z","updated":"2020-01-09T01:09:50.553Z","comments":true,"path":"2020/01/08/Node - 手动Proxy/","link":"","permalink":"http://irving.ren/2020/01/08/Node%20-%20%E6%89%8B%E5%8A%A8Proxy/","excerpt":"","text":"Node + koa 做服务代理踩坑奇遇记应用场景 有些时候，前端请求后端服务时，需改变请求参数格式、请求方法、跨域等其他需求时 基于 http123456789101112131415161718192021router.get(\"拦截的地址\", (ctx) =&gt; &#123; ctx.respond = false // 阻止koa原有写入，不设置会导致 write after end 错误 // 如果在发送请求时，需要设置head，可以把远程地址替换为请求配置信息， const httpReq = http.get(\"远程地址\", (res) =&gt; &#123; res.on(\"data\", (chun) =&gt; &#123; ctx.res.write(chun, (error =&gt; &#123; console.info(error) &#125;)) console.info(chun) &#125;) res.on(\"end\", () =&gt; &#123; ctx.res.end() // 结束响应写入，不调用会导致请求的连接无法结束，阻塞进程 &#125;) res.on(\"close\", () =&gt; &#123; console.info(\" close ==============\") &#125;) &#125;) httpReq.write(\"\") // 写入数据，自行格式化诸如json、form等格式&#125;) 基于node的http模块，自由度较高，但是所有内容均需要自己进行手写，例如：请求流的构建、响应的解析， 基于 axios，正常创建、配置axios对象进行请求的发送12345678910router.get(\"拦截的地址\", (ctx) =&gt; &#123; ctx.respond = false // 阻止koa原有写入，不设置会导致 write after end 错误 console.info(\"router append ================= \") axios.get(\"远程地址\").then((res) =&gt; &#123; console.info(res.data) ctx.res.write(res.data) ctx.res.end() // 同样需要手动结束 &#125;)&#125;) 基于axios成熟的类库进行构建，相对减少额外封装不必要的封装，适合请求或响应需要二次处理时使用，可避免再次编写请求流的构建和响应的解析 基于 http-proxy1234567891011121314151617181920212223242526272829303132333435// proxy 对象构建const proxy = HttpProxy.createProxyServer(&#123; // 配置proxy 信息 target: \"目标地址\"&#125;)proxy.on(\"proxyReq\", (proxyReq, req, res, &#123;&#125;) =&gt; &#123; // 调整目标地址 // 设置请求头&#125;)proxy.on(\"proxyRes\", (proxyRes, req, res) =&gt; &#123; &#125;)// proxy对象使用proxy.web(req, res)// 调用 proxy.web 的位置可以是 app.use((ctx,next)=&gt;&#123; // 根据请求地址、请求头或其他信息进行转发&#125;)router.get(\"拦截的地址\", (ctx)=&gt;&#123; // koa 路由中转发&#125;)// 覆盖响应proxy.on('proxyRes', function (proxyRes, req, res) &#123; var body = []; proxyRes.on('data', function (chunk) &#123; body.push(chunk); &#125;); proxyRes.on('end', function () &#123; body = Buffer.concat(body).toString(); console.log(\"res from proxied server:\", body); res.end(\"my response to cli\"); &#125;);&#125;); http-proxy 与 http 模块直接转发差异不大，目前还未找到如何修改请求体，相较于http，在配置的内容不多时，使用http-proxy会比较简单 请求头及响应头问题 在使用axios和http进行proxy的时候，需要注意请求的请求头和响应头，避免出现乱码或其他问题","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-01-01T02:17:55.685Z","updated":"2020-01-01T02:17:55.685Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"http://irving.ren/2020/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}